"""
DO NOT EDIT THIS FILE !!!
  _____     ____        _   _    ____    _______       ______   _____    _____   _______       _______   _    _   _____    _____       ______   _____   _        ______   _   _   _
 |  __ \   / __ \      | \ | |  / __ \  |__   __|     |  ____| |  __ \  |_   _| |__   __|     |__   __| | |  | | |_   _|  / ____|     |  ____| |_   _| | |      |  ____| | | | | | |
 | |  | | | |  | |     |  \| | | |  | |    | |        | |__    | |  | |   | |      | |           | |    | |__| |   | |   | (___       | |__      | |   | |      | |__    | | | | | |
 | |  | | | |  | |     | . ` | | |  | |    | |        |  __|   | |  | |   | |      | |           | |    |  __  |   | |    \___ \      |  __|     | |   | |      |  __|   | | | | | |
 | |__| | | |__| |     | |\  | | |__| |    | |        | |____  | |__| |  _| |_     | |           | |    | |  | |  _| |_   ____) |     | |       _| |_  | |____  | |____  |_| |_| |_|
 |_____/   \____/      |_| \_|  \____/     |_|        |______| |_____/  |_____|    |_|           |_|    |_|  |_| |_____| |_____/      |_|      |_____| |______| |______| (_) (_) (_)

"""


from django.test import TestCase, override_settings
from django.contrib import auth
from django.urls import reverse
from django.utils import timezone
from django.core import mail
from rest_framework.test import APIClient
from freezegun import freeze_time
import json

current_points = 0


class ExampleTest(TestCase):
    def setUp(self):
        # setUp run before every test method
        pass

    def test_something_that_will_pass(self):
        self.assertTrue(True)


class UC1_SignUpTests(TestCase):
    """UC1: create user"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 5  # number of tests in this suite
    points = 1  # points granted by this use case if all tests pass

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC1")

    def test_get_sign_up_form(self):
        """
        Get signup form, return status code 200
        """
        response = self.client.get(reverse("signup"))
        self.assertEqual(response.status_code, 200)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_sign_up_with_invalid_data(self):
        """
        REQ1.1
        Sign up without a password and email, should return status code 200
        """
        context = {
            "username": "testUser3",
        }

        response = self.client.post(reverse("signup"), context)
        self.assertEqual(response.status_code, 200)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_sign_up_with_valid_data(self):
        """
        REQ1.1
        Sign up with valid username and password, should return status code 302
        """
        context = {
            "username": "testUser3",
            "password": "123",
            "email": "user1@mail.com"
        }

        response = self.client.post(reverse("signup"), context)
        self.assertEqual(response.status_code, 302)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_sign_up_with_invalid_username(self):
        """
        REQ1.1
        Sign up with already taken username, should return status code 400.
        """
        context = {
            "username": "testUser1",
            "password": "333",
            "email": "user1@mail.com"
        }

        response1 = self.client.post(reverse("signup"), context)
        # create another user with the same username
        response2 = self.client.post(reverse("signup"), context)
        self.assertEqual(response2.status_code, 400)
        self.assertIn(b"This username has been taken", response2.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_sign_up_with_invalid_email(self):
        """
        REQ1.1
        Sign up with already taken email, should return status code 400.
        """
        user1Info = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }
        user2Info = {
            "username": "testUser2",
            "password": "321",
            "email": "user1@mail.com"
        }

        response1 = self.client.post(reverse("signup"), user1Info)
        # create another user with the same username
        response2 = self.client.post(reverse("signup"), user2Info)
        self.assertEqual(response2.status_code, 400)
        self.assertIn(b"This email has been taken", response2.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC2_EditProfileTests(TestCase):
    """UC2: edit user"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 4  # number of tests in this suite
    points = 1  # points granted by this use case if all tests pass

    def setUp(self):
        self.user1Info = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@yaas.com"
        }
        self.user2Info = {
            "username": "testUser2",
            "password": "321",
            "email": "user2@yaas.com"
        }
        # create a user for testing
        self.client.post(reverse("signup"), self.user1Info)
        self.client.post(reverse("signup"), self.user2Info)
        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC2")

    def test_get_profile_of_unauthenticated_user(self):
        """
        Get detail of unauthenticated user, return code 302 and redirect to signin page
        """
        response = self.client.get(reverse("user:editprofile"))
        self.assertEqual(response.status_code, 302)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_get_profile_of_authenticated_user(self):
        """
        Get detail of authenticated user, return code 200 authorized
        """
        self.client.post(reverse("signin"), self.user1Info)

        response = self.client.get(reverse("user:editprofile"))
        self.assertEqual(response.status_code, 200)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_edit_email_and_password_of_an_authenticated_user(self):
        """
        REQ2.2 & REQ2.3
        Edit email and password of an authenticated user, the user should have a new email and password
        """
        data = {
            "email": "newemail@dot.com",
            "password": "newpassword",
        }
        self.client.post(reverse("signin"), self.user1Info)

        response = self.client.post(reverse("user:editprofile"), data)
        user = auth.get_user(self.client)
        self.assertEqual(response.status_code, 302)
        self.assertEqual(user.email, "newemail@dot.com")

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_edit_email_that_already_taken(self):
        """
        REQ2.2 & REQ2.3
        Edit email of an authenticated user to the one that already taken, email stays the same
        """
        data = {
            "email": "user2@yaas.com"
        }

        # login and edit email of user1 to the email of user2
        self.client.post(reverse("signin"), self.user1Info)
        response = self.client.post(reverse("user:editprofile"), data)

        # get user1 and check if its email still stays the same
        user1 = auth.get_user(self.client)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(user1.email, "user1@yaas.com")  # stays the same as old email

        # calculate points
        self.__class__.number_of_passed_tests += 1


@override_settings(LANGUAGE_CODE='en-US', LANGUAGES=(('en', 'English'),))
class UC3_CreateAuctionTests(TestCase):
    """UC3: create auction"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 7  # number of tests in this suite
    points = 2  # points granted by this use case if all tests pass

    def setUp(self):
        self.userInfo = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }
        # create a user for testing
        self.client.post(reverse("signup"), self.userInfo)
        self.client.logout()  # because the signup function would signin the user

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC3")

    def test_get_create_auction_form(self):
        """
        REQ3.1
        Get create auction form, return code 200
        """
        self.client.post(reverse("signin"), self.userInfo)
        response = self.client.get(reverse("auction:create"))
        self.assertEqual(response.status_code, 200)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_create_auction_with_unauthenticated_user(self):
        """
        REQ3.1
        Create an auction with an unauthenticated user, should return a redirection status.
        """
        response = self.client.post(reverse("auction:create"))
        self.assertEqual(response.status_code, 302)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_create_auction_with_invalid_deadline_date(self):
        """
        REQ3.2
        Create auction with deadline date is earlier than current date, show error message
        """
        data = {
            "title": "newItem",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() - timezone.timedelta(hours=24)).strftime("%d.%m.%Y %H:%M:%S")  # 1 day ago
        }

        self.client.post(reverse("signin"), self.userInfo)
        response = self.client.post(reverse("auction:create"), data, follow=True)
        self.assertIn(b"The deadline date should be at least 72 hours from now", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_create_auction_with_invalid_deadline_date_format(self):
        """
        REQ3.2
        Create auction with invalid deadline date format, return error message
        """
        data = {
            "title": "newItem",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y")
        }
        self.client.post(reverse("signin"), self.userInfo)
        response = self.client.post(reverse("auction:create"), data, follow=True)
        self.assertIn(b"Enter a valid date/time", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_create_auction_with_invalid_minimum_price(self):
        """
        REQ3.2
        Create auction with invalid minimum price, the auction should not be created, response contains error message
        """
        data = {
            "title": "newItem",
            "description": "something",
            "minimum_price": 0,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }

        self.client.post(reverse("signin"), self.userInfo)
        response = self.client.post(reverse("auction:create"), data, follow=True)
        self.assertIn(b"Ensure this value is greater than or equal to 0.01", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_create_auction_with_valid_data(self):
        """
        REQ3.2
        Create auction with valid data, show success message.
        """
        data = {
            "title": "newItem",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }
        self.client.post(reverse("signin"), self.userInfo)
        response = self.client.post(reverse("auction:create"), data, follow=True)
        self.assertEqual(response.redirect_chain[0][1], 302)  # check redirect
        self.assertContains(response, b"Auction has been created successfully")

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_create_auction_with_sending_email(self):
        """
        REQ3.4
        Create auction with valid data and user has an email, show success message and an email is in outbox.
        """
        data = {
            "title": "newItem",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }
        self.client.post(reverse("signin"), self.userInfo)
        response = self.client.post(reverse("auction:create"), data, follow=True)

        self.assertEqual(len(mail.outbox), 1)  # notify seller
        self.assertEqual(response.redirect_chain[0][1], 302)  # check redirect
        self.assertContains(response, b"Auction has been created successfully")

        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC4_EditAuctionTests(TestCase):
    """UC4: edit auction description"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 4  # number of tests in this suite
    points = 1  # points granted by this use case if all tests pass

    def setUp(self):
        self.user1Info = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }
        self.user2Info = {
            "username": "testUser2",
            "password": "321",
            "email": "user2@mail.com"
        }
        data = {
            "title": "item1",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }

        # create a user and an auction
        self.client.post(reverse("signup"), self.user1Info)
        self.client.post(reverse("signin"), self.user1Info)
        self.client.post(reverse("auction:create"), data)
        self.auction_id = 1
        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC4")

    def test_get_an_auction_of_other_user(self):
        """
        REQ4.1
        Get an auction of other user, show the error message
        """
        data = {
            "description": "new content"
        }

        # login to user2 account
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)

        response = self.client.get(reverse("auction:edit", args=(self.auction_id,)), data, follow=True)
        self.assertIn(b"That is not your auction to edit", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_get_an_auction_successfully(self):
        """
        REQ4.1
        An user gets his auction successfully, return code 200
        """

        self.client.post(reverse("signin"), self.user1Info)
        response = self.client.get(reverse("auction:edit", args=(self.auction_id,)), follow=True)
        self.assertEqual(response.status_code, 200)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_edit_an_auction_of_other_user(self):
        """
        REQ4.1
        Get an auction of other user, show the error message
        """
        data = {
            "description": "new content"
        }

        # login to user2 account
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)

        response = self.client.post(reverse("auction:edit", args=(self.auction_id,)), data, follow=True)
        self.assertIn(b"That is not your auction", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_edit_auction_with_valid_description(self):
        """
        REQ4.1
        Edit an auction with valid description, response contains success message
        """
        data = {
            "title": "item1",
            "description": "new content"
        }

        self.client.post(reverse("signin"), self.user1Info)
        response = self.client.post(reverse("auction:edit", args=(self.auction_id,)), data, follow=True)
        self.assertEqual(response.redirect_chain[0][1], 302)
        self.assertContains(response, b"Auction has been updated successfully")

        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC5_BrowseAndSearchTests(TestCase):
    """UC5: browse and search auctions"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 2  # number of tests in this suite
    points = 1  # points granted by this use case if all tests pass

    def setUp(self):
        userInfo = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }

        data = {
            "title": "item1",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }
        # create a user and an auction
        self.client.post(reverse("signup"), userInfo)
        self.client.post(reverse("signin"), userInfo)
        self.client.post(reverse("auction:create"), data)
        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC5")

    def test_browse_for_active_auctions(self):
        """
        REQ5.1 & REQ5.3
        Test browse for active auctions, should return a list of active auctions
        """
        response = self.client.get(reverse("auction:index"))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.context["auctions"]), 1)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_search_for_auctions_by_title(self):
        """
        REQ5.2 & REQ5.4
        Test search for auctions by a title, should return a list of auctions which titles contain the term
        """
        args = {
            "term": "item1"
        }
        response = self.client.get(reverse("auction:search"), args)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.context["auctions"]), 1)

        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC6_BidAuctionTests(TestCase):
    """UC6: bid"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 6  # number of tests in this suite
    points = 3  # points granted by this use case if all tests pass

    def setUp(self):
        self.user1Info = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }

        self.user2Info = {
            "username": "testUser2",
            "password": "321",
            "email": "user2@mail.com"
        }

        item1Info = {
            "title": "item1",
            "description": "something",
            "minimum_price": 8,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }

        # create a user and an auction
        self.client.post(reverse("signup"), self.user1Info)
        self.client.post(reverse("signin"), self.user1Info)
        self.client.post(reverse("auction:create"), item1Info)
        # create an auction in the past
        with freeze_time("2019-9-5"):
            item2Info = {
                "title": "item2",
                "description": "something",
                "minimum_price": 10,
                "deadline_date": (timezone.now() + timezone.timedelta(days=4)).strftime("%d.%m.%Y %H:%M:%S")
            }
            self.client.post(reverse("auction:create"), item2Info)

        # common variables
        self.item1_id = 1
        self.item2_id = 2

        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC6")

    def test_bid_by_unauthenticated_user(self):
        """
        REQ6.1
        Unauthenticated user bid on an auction, return code 302 redirect
        """
        bidInfo = {
            "new_price": 12
        }

        response = self.client.post(reverse("auction:bid", args=(self.item1_id,)), bidInfo)
        self.assertEqual(response.status_code, 302)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_by_its_seller(self):
        """
        REQ6.3
        A seller bid on own auction, response contains error message
        """
        bidInfo = {
            "new_price": 12
        }

        # signup and signin to other user to bid
        self.client.post(reverse("signup"), self.user1Info)
        self.client.post(reverse("signin"), self.user1Info)

        response = self.client.post(reverse("auction:bid", args=(self.item1_id,)), bidInfo)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b"You cannot bid on your own auctions", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_on_inactive_auction(self):
        """
        REQ6.6
        Bid on an inactive auction, bid value does not change, return error message
        """
        adminInfo = {
            "username": "admin",
            "password": "admin",
            "email": "admin@mail.com"
        }

        bidInfo = {
            "new_price": 12
        }

        # create an admin user
        self.client.post(reverse("signup"), adminInfo)
        self.client.post(reverse("signin"), adminInfo)

        adm = auth.get_user(self.client)
        adm.is_superuser = True
        adm.save()

        # ban 1 item
        self.client.post(reverse("auction:ban", args=(self.item1_id,)))

        # signup and signin to other user to bid
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)

        response = self.client.post(reverse("auction:bid", args=(self.item1_id,)), bidInfo)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b"You can only bid on active auction", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_on_outdated_auction(self):
        """
        REQ6.6
        Bid on an auction that has outdated deadline date,  return error message
        """
        bidInfo = {
            "new_price": 12
        }
        # signup and signin to other user to bid
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)

        response = self.client.post(reverse("auction:bid", args=(self.item2_id,)), bidInfo)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b"You can only bid on active auction", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_with_invalid_amount(self):
        """
        REQ6.2 & REQ6.5
        Bid on an auction with invalid amount, should return error message
        """
        # signup and signin to other user to bid
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)

        bidInfo = {
            "new_price": 8
        }

        response = self.client.post(reverse("auction:bid", args=(self.item1_id,)), bidInfo)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b"New bid must be greater than the current bid for at least 0.01", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_with_valid_data(self):
        """
        REQ6.7 & REQ6.8
        Bid on an auction with valid data, response contains success message
        """
        bidInfo = {
            "new_price": 12
        }

        # signup and signin to other user to bid
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)

        response = self.client.post(reverse("auction:bid", args=(self.item1_id,)), bidInfo, follow=True)
        self.assertEqual(response.redirect_chain[0][1], 302)
        # 2 mails sent to seller when create 2 auctions
        # 2 mails sent to seller and bidder when bid
        self.assertEqual(len(mail.outbox), 4)
        self.assertContains(response, b"You has bid successfully")

        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC7_BanAuctionTests(TestCase):
    """UC7: ban auction"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 2  # number of tests in this suite
    points = 1  # points granted by this use case if all tests pass

    def setUp(self):
        self.userInfo = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }

        self.adminInfo = {
            "username": "admin",
            "password": "admin",
            "email": "admin@mail.com"
        }
        data = {
            "title": "item1",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }

        # create a user and an auction
        self.client.post(reverse("signup"), self.userInfo)
        self.client.post(reverse("signin"), self.userInfo)
        self.client.post(reverse("auction:create"), data)

        # create an admin user
        self.client.post(reverse("signup"), self.adminInfo)
        self.client.post(reverse("signin"), self.adminInfo)

        adm = auth.get_user(self.client)
        adm.is_superuser = True
        adm.save()

        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC7")

    def test_normal_user_ban_auction(self):
        """
        REQ7.1
        Normal user bans an auction, auction should remain unbanned
        """
        self.client.post(reverse("signin"), self.userInfo)

        response1 = self.client.post(reverse("auction:ban", args=(1,)))
        # get a list of active auctions, the testing auction should be in the list
        response2 = self.client.get(reverse("auction:index"))
        self.assertEqual(response1.status_code, 302)
        self.assertEqual(len(response2.context["auctions"]), 1)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_admin_ban_auction(self):
        """
        REQ7.1, REQ.7.3, REQ7.5
        Admin user bans an auction, auction should be banned
        """
        user2Info = {
            "username": "testUser2",
            "password": "321",
            "email": "user2@mail.com"
        }
        self.client.post(reverse("signup"), user2Info)
        self.client.post(reverse("signin"), user2Info)
        self.client.post(reverse("auction:bid", args=(1,)), {"new_price": 12})

        self.client.post(reverse("signin"), self.adminInfo)

        ban_response = self.client.post(reverse("auction:ban", args=(1,)), follow=True)
        # get a list of active auctions, the testing auction should not be in the list
        browse_response = self.client.get(reverse("auction:index"))

        self.assertEqual(ban_response.redirect_chain[0][1], 302)  # check redirecting
        self.assertIn(b"Ban successfully", ban_response.content)
        # 1 mail sent to seller after create auction
        # 2 mails sent to seller and bidder after bid
        # 2 other mails sent to seller and bidder to notify it being banned
        self.assertEqual(len(mail.outbox), 5)
        self.assertEqual(len(browse_response.context["auctions"]), 0)

        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC8_ResolveAuctionTests(TestCase):
    """UC8: Resolve auction"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 2  # number of tests in this suite
    points = 2  # points granted by this use case if all tests pass

    def setUp(self):
        self.user1Info = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }

        self.user2Info = {
            "username": "testUser2",
            "password": "321",
            "email": "user2@mail.com"
        }

        # create user1 and use it to create 2 auctions
        self.client.post(reverse("signup"), self.user1Info)
        self.client.post(reverse("signin"), self.user1Info)

        with freeze_time("2019-9-5"):
            item1Info = {
                "title": "item1",
                "description": "something",
                "minimum_price": 10,
                "deadline_date": (timezone.now() + timezone.timedelta(hours=80)).strftime("%d.%m.%Y %H:%M:%S")
            }

            item2Info = {
                "title": "item2",
                "description": "something else",
                "minimum_price": 9,
                "deadline_date": (timezone.now() + timezone.timedelta(hours=78)).strftime("%d.%m.%Y %H:%M:%S")
            }
            self.client.post(reverse("auction:create"), item1Info)
            self.client.post(reverse("auction:create"), item2Info)

        # create user2 to bid on item1
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)

        with freeze_time("2019-9-6"):
            self.client.post(reverse("auction:bid", args=(1,)), {"new_price": 12}, follow=True)

        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC8")

    def test_resolve_auctions(self):
        """
        REQ8.1
        Resolve auctions, return code 200, resolved auctions, list of active auctions should be empty
        """
        # call the resolve function
        resolve_response = self.client.get(reverse("auction:resolve"))
        # get the json result
        if isinstance(resolve_response.content, bytes):
            result = resolve_response.content.decode("utf-8")
        else:
            result = resolve_response.content
        result = json.loads(result)

        browse_response = self.client.get(reverse("auction:index"))

        self.assertEqual(resolve_response.status_code, 200)
        # check if the auction is not in the list of active auctions
        self.assertEqual(len(browse_response.context["auctions"]), 0)
        # check the resolved auctions
        self.assertEqual(result["resolved_auctions"][0], "item1")
        self.assertEqual(result["resolved_auctions"][1], "item2")

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_resolve_auction_and_send_emails(self):
        """
        REQ8.2 & REQ8.3
        Resolve auctions, return code 200, resolved auctions, list of active auctions should be empty, mails in outbox
        """
        # call the resolve function
        resolve_response = self.client.get(reverse("auction:resolve"))
        # get the json result
        if isinstance(resolve_response.content, bytes):
            result = resolve_response.content.decode("utf-8")
        else:
            result = resolve_response.content
        result = json.loads(result)

        browse_response = self.client.get(reverse("auction:index"))

        self.assertEqual(resolve_response.status_code, 200)
        # check if the auction is not in the list of active auctions
        self.assertEqual(len(browse_response.context["auctions"]), 0)
        # check the resolved auctions
        self.assertEqual(result["resolved_auctions"][0], "item1")
        self.assertEqual(result["resolved_auctions"][1], "item2")
        # 2 mails sent to seller after create 2 auctions
        # 2 mails sent to seller and bidder after bid
        # 3 mails sent to seller and 2 bidders after resolve
        self.assertEqual(len(mail.outbox), 7)
        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC9_ChangeLanguageTests(TestCase):
    """UC9: Language switching"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 2  # number of tests in this suite
    points = 2  # points granted by this use case if all tests pass

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC9")

    def test_change_language_to_swedish(self):
        """
        REQ9.1
        Change language to Swedish, response contains message
        """
        lang_code = "sv"
        response = self.client.get(reverse("changeLanguage", args=(lang_code,)))
        self.assertEqual(response.status_code, 200)
        self.assertIn(b"Language has been changed to Swedish", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_change_language_to_english(self):
        """
        REQ9.1
        Change language to Swedish, response contains message
        """
        lang_code = "en"
        response = self.client.get(reverse("changeLanguage", args=(lang_code,)))
        self.assertEqual(response.status_code, 200)
        self.assertIn(b"Language has been changed to English", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC10_BidConcurrencyTests(TestCase):
    """UC10: Concurrency"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 2  # number of tests in this suite
    points = 2  # points granted by this use case if all tests pass

    def setUp(self):
        self.user1Info = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }

        self.user2Info = {
            "username": "testUser2",
            "password": "321",
            "email": "user2@mail.com"
        }

        self.user3Info = {
            "username": "testUser3",
            "password": "213",
            "email": "user3@mail.com"
        }

        activeItemInfo = {
            "title": "item1",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }

        # create user1 and use it to create an auction
        self.client.post(reverse("signup"), self.user1Info)
        self.client.post(reverse("signin"), self.user1Info)
        self.client.post(reverse("auction:create"), activeItemInfo)

        # create 2 other users to test concurrent requests
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signup"), self.user3Info)

        # common variables
        self.auction_id = 1

        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC10")

    def test_bid_concurrently(self):
        """
        2 users bid on an auction concurrently, should return conflict message
        """
        # user2 bid on the auction, its bid and version have changed
        self.client.post(reverse("signin"), self.user2Info)
        response1 = self.client.post(reverse("auction:bid", args=(self.auction_id,)), {"new_price": 15})

        # user3 bid on the old version of the auction, conflict happens
        self.client.post(reverse("signin"), self.user3Info)
        response2 = self.client.post(reverse("auction:bid", args=(self.auction_id,)), {"new_price": 12})
        self.assertEqual(response1.status_code, 302)
        self.assertEqual(response2.status_code, 200)
        self.assertIn(b"The auction information has been changed", response2.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_on_changed_description_auction(self):
        """
        An auction has a change in description while bidding, should return conflict message
        """
        data = {
            "title": "item1",
            "description": "new content"
        }

        self.client.post(reverse("signin"), self.user1Info)
        response1 = self.client.post(reverse("auction:edit", args=(self.auction_id,)), data)

        self.client.post(reverse("signin"), self.user2Info)
        response2 = self.client.post(reverse("auction:bid", args=(self.auction_id,)), {"new_price": 15})
        self.assertEqual(response1.status_code, 302)
        self.assertEqual(response2.status_code, 200)
        self.assertIn(b"The auction information has been changed", response2.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1


class UC11_ChangeCurrencyTests(TestCase):
    """UC11: Currency exchange"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 2  # number of tests in this suite
    points = 2  # points granted by this use case if all tests pass

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "UC11")

    def test_change_currency_to_usd(self):
        currency_code = "USD"
        response = self.client.get(reverse("changeCurrency", args=(currency_code,)), follow=True)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b"Currency has been changed to USD", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_change_currency_to_eur(self):
        currency_code = "EUR"
        response = self.client.get(reverse("changeCurrency", args=(currency_code,)), follow=True)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b"Currency has been changed to EUR", response.content)

        # calculate points
        self.__class__.number_of_passed_tests += 1


class WS1_BrowseAndSearchAuctionApiTests(TestCase):
    """WS1: Browse and Search API"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 4  # number of tests in this suite
    points = 2  # points granted by this use case if all tests pass

    def setUp(self):
        userInfo = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }

        adminInfo = {
            "username": "admin",
            "password": "admin",
            "email": "admin@mail.com"
        }

        item1 = {
            "title": "item1",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }
        item2 = {
            "title": "item2",
            "description": "something",
            "minimum_price": 15,
            "deadline_date": (timezone.now() + timezone.timedelta(days=10)).strftime("%d.%m.%Y %H:%M:%S")
        }
        # create a user and auctions
        self.client.post(reverse("signup"), userInfo)
        self.client.post(reverse("signin"), userInfo)
        self.client.post(reverse("auction:create"), item1)
        self.client.post(reverse("auction:create"), item2)

        # create an admin user
        self.client.post(reverse("signup"), adminInfo)
        self.client.post(reverse("signin"), adminInfo)

        adm = auth.get_user(self.client)
        adm.is_superuser = True
        adm.save()
        # ban 1 item
        self.client.post(reverse("auction:ban", args=(2,)))

        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "WS1")

    def test_browse_active_auctions(self):
        """
        Browse for active auctions, return a list of active auctions
        """
        response = self.client.get(reverse("browseauctionsapi"))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["title"], "item1")

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_search_for_auctions_by_title(self):
        """
        Search for active auctions by title, return list of active auctions that contain that title
        """
        term = "item1"
        response = self.client.get(reverse("searchauctionapi", args=(term,)))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["title"], "item1")

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_search_for_auctions_by_title_with_term(self):
        """
        Search for active auctions by title, return list of active auctions that contain that title
        """
        args = {
            "term": "item1"
        }
        response = self.client.get(reverse("searchauctionwithtermapi"), args)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["title"], "item1")

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_search_for_auctions_by_id(self):
        """
        Search for active auctions by id, return an auction of that id
        """
        term = "1"
        response = self.client.get(reverse("searchauctionbyidapi", args=(term,)))
        self.assertEqual(response.status_code, 200)
        self.assertIsNotNone(response.data)
        self.assertEqual(response.data["title"], "item1")

        # calculate points
        self.__class__.number_of_passed_tests += 1


@override_settings(LANGUAGE_CODE='en-US', LANGUAGES=(('en', 'English'),))
class WS2_BidAuctionApiTests(TestCase):
    """WS2: bid API"""

    number_of_passed_tests = 0  # passed tests in this test case
    tests_amount = 6  # number of tests in this suite
    points = 2  # points granted by this use case if all tests pass

    def setUp(self):
        self.client = APIClient()
        # create user for testing purpose
        self.user1Info = {
            "username": "testUser1",
            "password": "123",
            "email": "user1@mail.com"
        }
        self.user2Info = {
            "username": "testUser2",
            "password": "321",
            "email": "user2@mail.com"
        }

        adminInfo = {
            "username": "admin",
            "password": "admin",
            "email": "admin@mail.com"
        }

        activeItemInfo = {
            "title": "item1",
            "description": "something",
            "minimum_price": 10,
            "deadline_date": (timezone.now() + timezone.timedelta(days=5)).strftime("%d.%m.%Y %H:%M:%S")
        }
        bannedItemInfo = {
            "title": "item2",
            "description": "something",
            "minimum_price": 15,
            "deadline_date": (timezone.now() + timezone.timedelta(days=8)).strftime("%d.%m.%Y %H:%M:%S")
        }

        # common variables
        self.active_item_id = 1
        self.banned_item_id = 2

        # create a user and an auction
        self.client.post(reverse("signup"), self.user1Info)
        self.client.post(reverse("signin"), self.user1Info)

        self.client.post(reverse("auction:create"), activeItemInfo)
        self.client.post(reverse("auction:create"), bannedItemInfo)
        # create an admin user
        self.client.post(reverse("signup"), adminInfo)
        self.client.post(reverse("signin"), adminInfo)

        adm = auth.get_user(self.client)
        adm.is_superuser = True
        adm.save()

        # ban 1 item
        self.client.post(reverse("auction:ban", args=(self.banned_item_id,)))

        self.client.logout()

    @classmethod
    def tearDownClass(cls):
        # check if test case passed or failed
        calculate_points(cls.number_of_passed_tests, cls.tests_amount, cls.points, "WS2")

    def test_unauthenticated_user_bid(self):
        """
        Unauthenticated user accessing the API, return code 401 and error message
        """
        response = self.client.post(reverse("bidauctionapi", args=(self.active_item_id,)))
        self.assertEqual(response.status_code, 401)
        self.assertIn("Authentication credentials were not provided", response.data["detail"])

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_on_own_auction(self):
        """
        Bid on own auction, return error code 400
        """
        data = {
            "new_price": 12
        }
        self.client.post(reverse("signin"), self.user1Info)
        self.client.force_authenticate(user=auth.get_user(self.client))

        response = self.client.post(reverse("bidauctionapi", args=(self.active_item_id,)), data)
        self.assertEqual(response.status_code, 400)
        self.assertIn("Cannot bid on own auction", response.data["message"])

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_on_banned_auction(self):
        """
        Bid on banned auction, return code 400
        """
        data = {
            "new_price": 12
        }
        self.client.post(reverse("signin"), self.user2Info)
        self.client.post(reverse("signup"), self.user2Info)
        self.client.force_authenticate(user=auth.get_user(self.client))

        response = self.client.post(reverse("bidauctionapi", args=(self.banned_item_id,)), data)
        self.assertEqual(response.status_code, 400)
        self.assertIn("Can only bid on active auction", response.data["message"])

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_with_invalid_amount(self):
        """
        Bid with a new bid is the same with the old bid, return code 400
        """
        data = {
            "new_price": 10
        }
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)
        self.client.force_authenticate(user=auth.get_user(self.client))

        response = self.client.post(reverse("bidauctionapi", args=(self.active_item_id,)), data)
        self.assertEqual(response.status_code, 400)
        self.assertIn("New bid must be greater than the current bid at least 0.01", response.data["message"])

        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_with_invalid_data(self):
        """
        Bid with invalid data, return code 400
        """
        data = {
            "new_price": "text"
        }
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)
        self.client.force_authenticate(user=auth.get_user(self.client))

        response = self.client.post(reverse("bidauctionapi", args=(self.active_item_id,)), data)
        self.assertEqual(response.status_code, 400)
        self.assertIn("Bid must be a number", response.data["message"])
        # calculate points
        self.__class__.number_of_passed_tests += 1

    def test_bid_successfully(self):
        """
        Bid on other auction successfully, return code 200
        """
        data = {
            "new_price": 12
        }
        self.client.post(reverse("signup"), self.user2Info)
        self.client.post(reverse("signin"), self.user2Info)
        self.client.force_authenticate(user=auth.get_user(self.client))

        response = self.client.post(reverse("bidauctionapi", args=(self.active_item_id,)), data)
        self.assertEqual(response.status_code, 200)
        # 2 mails sent to seller after create 2 auctions
        # 1 mail sent to seller after an auction being banned
        # 2 mails sent to seller and bidder after bid
        self.assertEqual(len(mail.outbox), 5)
        self.assertIn("Bid successfully", response.data["message"])
        self.assertEqual(response.data["title"], "item1")
        self.assertEqual(response.data["current_price"], 12)

        # calculate points
        self.__class__.number_of_passed_tests += 1


def calculate_points(number_of_passed_tests, amount_of_tests, points_of_the_use_case, use_case_name):
    if number_of_passed_tests < amount_of_tests:
        print("{} fails!".format(use_case_name))
    else:
        global current_points
        current_points += points_of_the_use_case
        message = "{} passed, {} points, Current points: {}/30".format(use_case_name, points_of_the_use_case, current_points)
        print(message)